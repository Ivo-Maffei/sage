

# This file was *autogenerated* from the file sage/src/sage/graphs/distance_regular/tests/tests.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1200 = Integer(1200); _sage_const_500000 = Integer(500000); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_7 = Integer(7); _sage_const_8 = Integer(8); _sage_const_9 = Integer(9); _sage_const_11 = Integer(11); _sage_const_13 = Integer(13); _sage_const_16 = Integer(16); _sage_const_17 = Integer(17); _sage_const_19 = Integer(19); _sage_const_23 = Integer(23); _sage_const_25 = Integer(25); _sage_const_27 = Integer(27); _sage_const_29 = Integer(29); _sage_const_31 = Integer(31); _sage_const_32 = Integer(32); _sage_const_37 = Integer(37); _sage_const_41 = Integer(41); _sage_const_43 = Integer(43); _sage_const_47 = Integer(47); _sage_const_49 = Integer(49); _sage_const_53 = Integer(53); _sage_const_59 = Integer(59); _sage_const_61 = Integer(61); _sage_const_64 = Integer(64); _sage_const_67 = Integer(67); _sage_const_71 = Integer(71); _sage_const_73 = Integer(73); _sage_const_79 = Integer(79); _sage_const_81 = Integer(81); _sage_const_83 = Integer(83); _sage_const_89 = Integer(89); _sage_const_97 = Integer(97); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_6 = Integer(6); _sage_const_10 = Integer(10); _sage_const_12 = Integer(12); _sage_const_50 = Integer(50); _sage_const_100 = Integer(100); _sage_const_20 = Integer(20); _sage_const_1000 = Integer(1000)
from sage.graphs.distance_regular import *
from sage.graphs.distance_regular import _sporadic_graph_database

from sage.arith.misc import binomial
from sage.combinat.q_analogues import q_binomial
from sage.functions.other import sqrt
from time import time

from sage.parallel.decorate import fork

timeLimit = _sage_const_1200  #20 min
edgeLimit = _sage_const_500000 
warning = "WARNING!!!!!!!!"
prime_powers = [_sage_const_2 ,_sage_const_3 ,_sage_const_4 ,_sage_const_5 ,_sage_const_7 ,_sage_const_8 ,_sage_const_9 ,_sage_const_11 ,_sage_const_13 ,_sage_const_16 ,_sage_const_17 ,_sage_const_19 ,_sage_const_23 ,_sage_const_25 ]
prime_powers_large = prime_powers + [_sage_const_27 ,_sage_const_29 ,_sage_const_31 ,_sage_const_32 ,_sage_const_37 ,_sage_const_41 ,_sage_const_43 ,_sage_const_47 ,_sage_const_49 ,_sage_const_53 ,_sage_const_59 ,_sage_const_61 ,_sage_const_64 ,_sage_const_67 ,_sage_const_71 ,_sage_const_73 ,_sage_const_79 ,_sage_const_81 ,_sage_const_83 ,_sage_const_89 ,_sage_const_97 ]

#@fork(timeout=timeLimit,verbose=False)
def timeout_wrapper(f,*t):
    return f(*t)

def test_sporadic():
    ok = _sage_const_0 
    fail = _sage_const_0 
    for arr in _sporadic_graph_database:
        start = time()
        G = _sporadic_graph_database[arr]()
        end = time()
        if tuple(intersection_array_from_graph(G)) != arr:
            print("{} {} failed".format(warning,arr))
            fail+= _sage_const_1 
        else:
            print("{} success ({} edges in {})".format(arr,G.size(),end-start))
            ok += _sage_const_1 

    return (ok,fail)

def call_wrapper(f,obj,unpack):
    if unpack:
        return f(*obj)
    else:
        return f(obj)

def is_iterable(obj):
    try:
        iter(obj)
    except TypeError:
        return False
    return True

def test_function(name,graph,params,array,edges=None,fromArray=False):

    ok = _sage_const_0 
    fail = _sage_const_0 
    iterable = True #assume true; doesn't matter

    def edgesDefault(arr):
        try:
            nE = arr[_sage_const_0 ]*number_of_vertices_from_intersection_array(arr) // _sage_const_2 
        except OverflowError:
            return edgeLimit+_sage_const_1 
        return nE

    def edgesWrapper(t):
        try:
            nE = call_wrapper(edges,t,iterable)
        except OverflowError:
            return edgeLimit +_sage_const_1 
        return nE

    for t in params():#parmas is a generator
        iterable = is_iterable(t)
        if edges is None:
            arr = call_wrapper(array,t,iterable)
            nE = edgesDefault(arr)
            if nE > edgeLimit: continue
        else:
            nE = edgesWrapper(t)
            if nE > edgeLimit: continue
            arr = call_wrapper(array,t,iterable)

        start = time()
        if fromArray:
            G = distance_regular_graph(arr,check=False)
        else:
            G = call_wrapper(graph,t,iterable)
        end = time()
        if type(G) == type(""):#graph not builted because of timeout
            fail += _sage_const_1 
            print("{} with parameters {} and timeout after {}".format(name,t,timeLimit))
        elif intersection_array_from_graph(G) == arr:
            ok += _sage_const_1 
            print("{} with parameters {} success ({} vertices, {} edges in {})".format(name,t,G.order(),G.size(),end-start))
        else:
            fail += _sage_const_1 
            print("{} {} with parameters {} failed".format(warning,name,t))

        #sanity check on edge function
        if edges is not None and type(G) != type("") and nE != G.size():
            print("{} {} edges function is wrong".format(warning,name))

    return (ok,fail)

def dual_polar_orthogonal_params():
    for d in range(_sage_const_3 ,_sage_const_6 ):
            for q in prime_powers[:_sage_const_7 ]:
                yield (_sage_const_0 ,d,q)
                yield (_sage_const_1 ,d,q)
                yield (-_sage_const_1 ,d,q)

def dual_polar_orthogonal_array(e,d,q):
    return intersection_array_from_classical_parameters(d,q,_sage_const_0 ,q**(_sage_const_1 -e))

def doubled_odd_params():
    for n in range(_sage_const_8 ):#values >= 8 is_distance_regular gives an error
            yield n

def doubled_odd_array(x):
    k = x+_sage_const_1 
    d = _sage_const_2 *x + _sage_const_1 

    cs = [ (i+_sage_const_1 ) // _sage_const_2  for i in range(d+_sage_const_1 )]
    bs = [ k - cs[i] for i in range(d)]

    return bs+cs[_sage_const_1 :]

def doubled_odd_edges(x):
    return binomial(_sage_const_2 *x+_sage_const_1 ,x)*(x+_sage_const_1 )

def bilinear_form_params():
    for d in range(_sage_const_3 ,_sage_const_10 ):
        for e in range(d,_sage_const_10 ):
            for q in prime_powers:
                yield (d,e,q)

def bilinear_form_array(d,e,q):
    return intersection_array_from_classical_parameters(d,q,q-_sage_const_1 ,q**e-_sage_const_1 )

def bilinear_form_edges(d,e,q):
    return q**(d*e)*q_binomial(d,_sage_const_1 ,q)*(q**e-_sage_const_1 ) // _sage_const_2 

def alternating_form_params():
    for n in range(_sage_const_6 ,_sage_const_12 ):#n<6 => d < 3
        for q in prime_powers:
            yield (n,q)

def alternating_form_array(n,q):
    m = _sage_const_2  * (n+_sage_const_1 )//_sage_const_2  -_sage_const_1 
    return intersection_array_from_classical_parameters(n//_sage_const_2 ,q*q,q*q-_sage_const_1 ,q**m-_sage_const_1 )

def alternating_form_edges(n,q):
    nV = (n-_sage_const_1 )*n // _sage_const_2 
    nV = q**nV
    m = _sage_const_2 *(n+_sage_const_1 )//_sage_const_2  -_sage_const_1 
    k = q_binomial(n//_sage_const_2 ,_sage_const_1 ,q)*(q**m-_sage_const_1 )
    return k*nV // _sage_const_2 

def hermitian_form_params():
    for n in range(_sage_const_3 ,_sage_const_10 ):
        for q in prime_powers:
            yield (n,q*q)

def hermitian_form_array(n,q):
    r = sqrt(q)
    return intersection_array_from_classical_parameters(n, -r, -r-_sage_const_1 , -(-r)**n-_sage_const_1 )
    
def hermitian_form_edges(n,q):
    r = sqrt(q)
    nV = (n-_sage_const_1 )*n // _sage_const_2 
    nV = (q**nV) * (r**n)
    k = q_binomial(n,_sage_const_1 ,-r)*(-(-r)**n-_sage_const_1 )
    return nV*k // _sage_const_2 

def halved_cube_params():
    for  n in range(_sage_const_6 ,_sage_const_50 ):#smaller n has diameter < 3
        yield n

def halved_cube_array(n):
    return intersection_array_from_classical_parameters(n//_sage_const_2 ,_sage_const_1 ,_sage_const_2 ,_sage_const_2 *((n+_sage_const_1 )//_sage_const_2 )-_sage_const_1 )

def halved_cube_edges(n):
    nV = _sage_const_2 **(n-_sage_const_1 )
    k = n-_sage_const_1  + binomial(n-_sage_const_1 ,_sage_const_2 )
    return nV*k//_sage_const_2 

def Grassmann_params():
    for e in range(_sage_const_3 ,_sage_const_7 ):#diameter is e
        for n in range(_sage_const_2 *e,_sage_const_10 ):
            for q in prime_powers[:_sage_const_5 ]:#q>7 is too big
                yield (q,n,e)

def Grassmann_array(q,n,e):
    return intersection_array_from_classical_parameters(e,q,q,q_binomial(n-e+_sage_const_1 ,_sage_const_1 ,q)-_sage_const_1 )

def Grassmann_edges(q,n,e):
    nV = q_binomial(n,e,q)
    k = q_binomial(e,_sage_const_1 ,q)*(q_binomial(n-e+_sage_const_1 ,_sage_const_1 ,q) -_sage_const_1 )
    return nV*k//_sage_const_2 

def doubled_Grassmann_params():
    for e in range(_sage_const_1 ,_sage_const_10 ):#diameter is 2e+1
        for q in prime_powers[:_sage_const_5 ]:#to big otherwise
            yield (q,e)

def doubled_Grassmann_array(q,e):
    d = _sage_const_2 *e +_sage_const_1 
    cs = [ q_binomial((i+_sage_const_1 )//_sage_const_2 ,_sage_const_1 ,q) for i in range(d+_sage_const_1 )]
    bs = [ q_binomial(e+_sage_const_1 ,_sage_const_1 ,q)-cs[i] for i in range(d)]
    return bs+cs[_sage_const_1 :]

def doubled_Grassmann_edges(q,e):
    nV = _sage_const_2 *q_binomial(_sage_const_2 *e+_sage_const_1 ,e,q)
    k= q_binomial(e+_sage_const_1 ,_sage_const_1 ,q)
    return k*nV//_sage_const_2 

def hermitian_cover_params():
    for q in prime_powers:
        for r in (q*q -_sage_const_1 ).divisors()[_sage_const_1 :]:#r==1 is complete graph
            if( (r%_sage_const_2  == _sage_const_1  and (q-_sage_const_1 )%r == _sage_const_0 ) or
                (q%_sage_const_2  == _sage_const_0  and (q+_sage_const_1 )%r == _sage_const_0 ) or
                (q%_sage_const_2  == _sage_const_1  and ((q+_sage_const_1 )//_sage_const_2 )%r == _sage_const_0 )):
                yield (q,r)

def hermitian_cover_array(q,r):
    #diameter 3 r cover of K_{q^3+1}
    if r%_sage_const_2  == _sage_const_1  and (q-_sage_const_1 )%r == _sage_const_0 :
        mu = (q**_sage_const_3 -_sage_const_1 )//r
    else:
        mu = (q+_sage_const_1 )*( (q**_sage_const_2 -_sage_const_1 )//r )
    return [q**_sage_const_3 ,(r-_sage_const_1 )*mu,_sage_const_1 ,_sage_const_1 ,mu,q**_sage_const_3 ]

def hermitian_cover_edges(q,r):
    nV = r*(q**_sage_const_3 +_sage_const_1 )
    return nV*q**_sage_const_3  // _sage_const_2 

def AB_params():
    for m in range(_sage_const_1 ,_sage_const_100 ):#m=0->n=1->graph is not connected
        n = _sage_const_2 *m+_sage_const_1 
        yield n

def AB_array(n):
    return [_sage_const_2 **n-_sage_const_1 , _sage_const_2 **n-_sage_const_2 , _sage_const_2 **(n-_sage_const_1 )+_sage_const_1 , _sage_const_1 , _sage_const_2 , _sage_const_2 **(n-_sage_const_1 )-_sage_const_1 ]

def AB_edges(n):
    nV = _sage_const_2 **(_sage_const_2 *n-_sage_const_1 )#num vertices // 2
    return nV*(_sage_const_2 **n-_sage_const_1 )

def Preparata_params():
    for t in range(_sage_const_1 ,_sage_const_50 ):
        for i in range(_sage_const_2 *t-_sage_const_1 ):
            yield(t,i)

def Preparata_array(t,i):
    q = _sage_const_2 **(_sage_const_2 *t-_sage_const_1 )
    p = _sage_const_2 **(i+_sage_const_1 )
    return [_sage_const_2 *q-_sage_const_1 ,_sage_const_2 *q-p,_sage_const_1 ,_sage_const_1 ,p,_sage_const_2 *q-_sage_const_1 ]

def Preparata_edges(t,i):
    q = _sage_const_2 **(_sage_const_2 *t-_sage_const_1 )
    p = _sage_const_2 **i
    nV = q*(q//p) #n vertices /2
    return nV*(_sage_const_2 *q-_sage_const_1 )

def Brouwer_Pasechnik_params():
    for q in prime_powers:
        yield q

def Brouwer_Pasechnik_array(q):
    return [q**_sage_const_3 -_sage_const_1 ,q**_sage_const_3 -q,q**_sage_const_3 -q**_sage_const_2 +_sage_const_1 ,_sage_const_1 ,q,q**_sage_const_2 -_sage_const_1 ]

def Brouwer_Pasechnik_edges(q):
    nV = q**_sage_const_6 
    return nV*(q**_sage_const_3 -_sage_const_1 )//_sage_const_2 

def Pasechnik_params():
    for q in prime_powers:
        yield q

def Pasechnik_array(q):
    return [q**_sage_const_3 ,q**_sage_const_3 -_sage_const_1 ,q**_sage_const_3 -q,q**_sage_const_3 -q**_sage_const_2 +_sage_const_1 ,_sage_const_1 ,q,q**_sage_const_2 -_sage_const_1 ,q**_sage_const_3 ]

def Pasechnik_edges(q):
    nV = q**_sage_const_6  #num vertices / 2
    return nV*(q**_sage_const_3 )

def association_scheme_params():
    #if new association schemes are added
    #this function should be updated
    for q in prime_powers_large:
        for r in (q-_sage_const_1 ).divisors()[_sage_const_1 :]:#avoid r ==1, which is complete graph
            if distance_regular_association_scheme(q,r,existence=True) is True:
                yield(q,r)

def association_scheme_array(q,r):
    mu = (q-_sage_const_1 )//r
    return [r*mu+_sage_const_1 ,(r-_sage_const_1 )*mu,_sage_const_1 ,_sage_const_1 ,mu,r*mu+_sage_const_1 ]

def association_scheme_edges(q,r):
    nV = (q+_sage_const_1 )*r
    return nV*q // _sage_const_2 

def GQ_graph_params():
    #if new GQ with spread are added
    #this function should be update
    for q in prime_powers:
        yield (q,q*q)

def GQ_graph_array(s,t):
    return [s*t,s*(t-_sage_const_1 ),_sage_const_1 ,_sage_const_1 ,t-_sage_const_1 ,s*t]

def GQ_graph_edges(s,t):
    return (s+_sage_const_1 )*(s*t+_sage_const_1 )*s*t // _sage_const_2 

def gen_symplectic_params():
    for m in range(_sage_const_1 ,_sage_const_50 ):
        n = _sage_const_2 *m
        for q in prime_powers:
            for r in q.divisors()[_sage_const_1 :]:#r==1 we get complete graph
                yield (q,n,r)

def gen_symplectic_array(q,n,r):
    qn = q**n
    return [qn-_sage_const_1 ,((r-_sage_const_1 )*qn)//r,_sage_const_1 ,_sage_const_1 ,qn//r,qn-_sage_const_1 ]

def gen_symplectic_edges(q,n,r):
    nV = q**n * r
    return nV*(q**n-_sage_const_1 )//_sage_const_2 

def BIBD_graph_params():
    #this is complecated to predict
    #so go wild
    #we do know that graph has v*k edges
    #no trivial cases k<=2 or v == k
    for v in range(_sage_const_4 ,edgeLimit):
        for k in range(_sage_const_3 ,v):#k<v is obvious
            l = (k*(k-_sage_const_1 ))//(v-_sage_const_1 )
            if designs.balanced_incomplete_block_design(v,k,lmbd=l,existence=True) is True:
                yield(v,k)

def BIBD_graph_array(v,k):
    l = (k*(k-_sage_const_1 ))//(v-_sage_const_1 )
    return [k,k-_sage_const_1 ,k-l,_sage_const_1 ,l,k]

def BIBD_graph_edges(v,k):
    return v*k

def Denniston_arc_params():
    for i in range(_sage_const_1 ,_sage_const_20 ):
        n = _sage_const_2 **i
        yield n

def Denniston_arc_array(n):
    return [n*n-n+_sage_const_1 , n*(n-_sage_const_1 ), n*(n-_sage_const_1 ), n,_sage_const_1 ,_sage_const_1 , (n-_sage_const_1 )**_sage_const_2 , n*n-n+_sage_const_1 ]

def Denniston_arc_edges(n):
    return (n*n+_sage_const_1 )*(n*n-n+_sage_const_1 )**_sage_const_2 

def unitary_graph_params():
    for q in prime_powers[_sage_const_1 :]: #q>2
        yield q

def unitary_graph_array(q):
    return [q*q-q,q*q-q-_sage_const_2 ,q+_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,q*q-_sage_const_2 *q]

def Taylor_graph_params():
    #if more twographs are implemented
    #this function should change
    for q in prime_powers[_sage_const_1 :]: #odd prime
        if q % _sage_const_2  == _sage_const_0 : continue
        n = q**_sage_const_3 +_sage_const_1 
        l = (q-_sage_const_1 )*(q*q+_sage_const_1 )//_sage_const_2 
        yield (n,l)
        yield (n, n-_sage_const_2  -l)

def Taylor_graph_array(n,l):
    k = n-_sage_const_1 
    mu = k-_sage_const_1 -l
    return [k,mu,_sage_const_1 ,_sage_const_1 ,mu,k]

def Taylor_graph_edges(n,l):
    return n*(n-_sage_const_1 )

def TD_graph_params():
    #wild as for BIBD
    #edges is n^3 l^2
    for n in range(_sage_const_2 ,_sage_const_100 ):
        for l in range(_sage_const_1 ,_sage_const_1000 ):
            if designs.symmetric_net(n,l,existence=True) is True:
                yield (n,l)

def TD_graph_array(n,l):
    return [n*l,n*l-_sage_const_1 ,(n-_sage_const_1 )*l,_sage_const_1 ,_sage_const_1 ,l,n*l-_sage_const_1 ,n*l]

def TD_graph_edges(n,l):
    nBlocks = n*n*l #which is half of vertices
    return nBlocks*n*l

def gen_dodec_params():
    for q in [_sage_const_2 ,_sage_const_3 ,_sage_const_4 ,_sage_const_5 ]:
        yield (_sage_const_1 ,q)
        yield (q,_sage_const_1 )

def gen_poly_array(n,s,t):
    d = n//_sage_const_2 
    cs = [ _sage_const_1  for i in range(d) ]
    cs[d-_sage_const_1 ] = t+_sage_const_1 

    k = s*(t+_sage_const_1 )
    bs = [k] + [ s*t for i in range(d-_sage_const_1 ) ]

    return bs+cs

def gen_dodec_array(s,t):
    return gen_poly_array(_sage_const_12 ,s,t)

def gen_octagon_params():
    
    yield (_sage_const_2 ,_sage_const_4 )
    yield (_sage_const_4 ,_sage_const_2 )
    
    for q in prime_powers:
        if graphs.strongly_regular_graph((q+_sage_const_1 )*(q*q+_sage_const_1 ),q*(q+_sage_const_1 ),q-_sage_const_1 ,q+_sage_const_1 ,existence=True) is True:
            yield (_sage_const_1 ,q)
            yield (q,_sage_const_1 )

def gen_octagon_array(s,t):
    return gen_poly_array(_sage_const_8 ,s,t)

def gen_hexagon_params():

    #G_2(q)
    yield (_sage_const_2 ,_sage_const_2 )
    yield (_sage_const_3 ,_sage_const_3 )
    yield (_sage_const_4 ,_sage_const_4 )
    yield (_sage_const_5 ,_sage_const_5 )

    #3D4
    yield (_sage_const_2 ,_sage_const_8 )
    yield (_sage_const_8 ,_sage_const_2 )
    yield (_sage_const_3 ,_sage_const_27 )
    yield (_sage_const_27 ,_sage_const_3 )
    
    for q in prime_powers:
        yield (_sage_const_1 ,q)
        yield (q,_sage_const_1 )

def gen_hexagon_array(s,t):
    return gen_poly_array(_sage_const_6 ,s,t)

def Kasami_params():
    for i in range(_sage_const_1 ,_sage_const_20 ):
        q = _sage_const_2 **i
        yield (q*q,q)
        for j in range(_sage_const_10 ):
            for m in range(_sage_const_1 ,j+_sage_const_1 ):
                if gcd(m,_sage_const_2 *j+_sage_const_1 ) == _sage_const_1 :
                    yield (q**(_sage_const_2 *j+_sage_const_1 ), q**m)

def Kasami_array(s,t):
    if s == t*t:
        return [s-_sage_const_1 ,s-t,_sage_const_1 ,_sage_const_1 ,t,s-_sage_const_1 ]
    else:
        (p,k) = is_prime_power(t,get_data=True)
        (p,h) = is_prime_power(s,get_data=True)
        i = gcd(k,h)
        #i is largest number dividing k and h
        #so m = k//i and 2j+1 = h // i
        q = _sage_const_2 **i
        return [s-_sage_const_1 ,s-q,(s//q)*(q-_sage_const_1 )+_sage_const_1 ,_sage_const_1 ,q,(s//q)-_sage_const_1 ]

def Kasami_edges(s,t):
    if s == t*t:
        return (s*t)//_sage_const_2  * (s-_sage_const_1 )
    else:
        return s*s//_sage_const_2  * (s-_sage_const_1 )

def extended_Kasami_array(s,t):
    if s == t*t:
        return [s,s-_sage_const_1 ,s-t,_sage_const_1 ,_sage_const_1 ,t,s-_sage_const_1 ,s]
    else:
        (p,k) = is_prime_power(t,get_data=True)
        (p,h) = is_prime_power(s,get_data=True)
        i = gcd(h,k)
        q = _sage_const_2 **i
        return [s,s-_sage_const_1 ,s-q,(s//q)*(q-_sage_const_1 )+_sage_const_1 ,_sage_const_1 ,q,(s//q)-_sage_const_1 ,s]

def extended_Kasami_edges(s,t):
    if s == t*t:
        return s*t*s
    else:
        return s*s*s
        
    
_tests_list = [
    #("sporadic graphs",test_sporadic),
    #("orthogonal dual polar",dual_polar_orthogonal,dual_polar_orthogonal_params,dual_polar_orthogonal_array),
    #("doubled odd", doubled_odd_graph, doubled_odd_params, doubled_odd_array, doubled_odd_edges),
    #("bilinear form graph",bilinear_form_graph,bilinear_form_params,bilinear_form_array,bilinear_form_edges),
    #("alternating form graph",alternating_form_graph,alternating_form_params,alternating_form_array,alternating_form_edges), #to test
    #("hermitian form graph",hermitian_form_graph,hermitian_form_params,hermitian_form_array,hermitian_form_edges),
    #("halved cube",halved_cube,halved_cube_params,halved_cube_array,halved_cube_edges),
    #("Grassmann",Grassmann_graph,Grassmann_params,Grassmann_array,Grassmann_edges),
    #("doubled Grassmann",doubled_Grassmann_graph,doubled_Grassmann_params,doubled_Grassmann_array,doubled_Grassmann_edges),
    #("hermitian cover",hermitian_cover,hermitian_cover_params,hermitian_cover_array,hermitian_cover_edges),
    #("AB graph",AB_graph,AB_params,AB_array,AB_edges),
    #("Preparata graph", Preparata_graph,Preparata_params,Preparata_array,Preparata_edges),
    #("Brouwer Pasechnik graph",Brouwer_Pasechnik_graph,Brouwer_Pasechnik_params,Brouwer_Pasechnik_array,Brouwer_Pasechnik_edges),
    #("Pasechnik graph",Pasechnik_graph,Pasechnik_params,Pasechnik_array,Pasechnik_edges),
    #("Association scheme graph",graph_from_association_scheme, association_scheme_params ,association_scheme_array, association_scheme_edges), #test primes > 100 and error in drg for (13,2)
    #("GQ graphs",graph_from_GQ_spread, GQ_graph_params,GQ_graph_array,GQ_graph_edges),
    #("Symplectic cover", symplectic_cover, gen_symplectic_params, gen_symplectic_array, gen_symplectic_edges),
    #("BIBD graph", graph_from_BIBD, BIBD_graph_params, BIBD_graph_array, BIBD_graph_edges), #to test big ones
    #("Denniston graph", graph_from_Denniston_arc, Denniston_arc_params, Denniston_arc_array, Denniston_arc_edges),
    #("unitary nonisotropic graph",unitary_nonisotropic_graph, unitary_graph_params, unitary_graph_array),
    #("Taylor graph",Taylor_graph, Taylor_graph_params, Taylor_graph_array, Taylor_graph_edges),
    #("TD graph",graph_from_TD,TD_graph_params,TD_graph_array,TD_graph_edges),
    #("Generalised dodecagon",generalised_dodecagon, gen_dodec_params,gen_dodec_array),
    #("Generalised octagon",generalised_octagon, gen_octagon_params,gen_octagon_array),
    #("Generalised hexagon", generalised_hexagon, gen_hexagon_params, gen_hexagon_array),
    #("Kasami graph",Kasami_graph,Kasami_params,Kasami_array,Kasami_edges),
    ("Extended Kasami graph",extended_Kasami_graph,Kasami_params,extended_Kasami_array,extended_Kasami_edges),
]

def test_all(fromArray=False):
    totalOK = _sage_const_0 
    totalFail = _sage_const_0 

    for t in _tests_list:
        name = t[_sage_const_0 ]
        print("start testing {}".format(name))
        
        lt = len(t)
        if lt == _sage_const_2 :
            (ok,fail) = t[_sage_const_1 ]()
        else:
            graph = t[_sage_const_1 ]
            params = t[_sage_const_2 ]
            array = t[_sage_const_3 ]
            edges = None if lt == _sage_const_4  else t[_sage_const_4 ]
            res = timeout_wrapper(test_function,name,graph,params,array,edges,fromArray)
            if type(res) == type(""):
                print("timeout..., not counting")
                (ok,fail) = (_sage_const_0 ,_sage_const_0 )
            else:
                (ok,fail) = res
    
        totalOK += ok
        totalFail += fail
        print("{} terminated: fail {}, ok {}, total {}".format(name,fail,ok,ok+fail))
        print("-------------------------------------------------------")

    print("All functions tested")
    print("Tests passed {}, failed {}, total {}".format(totalOK, totalFail, totalOK+totalFail))


def test_random_array(n, drange, maxV , noConstraints=False):
    #we generate n random arrays
    #they should have diameter in drange
    #each entry in the array is <= maxV (use to bound the graph size)
    #size of graph is < maxV * (maxV^d-1)/(maxV-1) / 2
    #if noConstraints is True, then arrays are completely random
    #otherwise we ensure c_1 =1 and c[i] <= c[i+1]
    #and b[i] >= b[i+1] and a_i >=0
    from numpy.random import randint
    D = len(drange)
    ds = randint(_sage_const_0 ,D,n)

    for v in range(n):
        d = drange[ds[v]]
        if noConstraints:
            arr = list(randint(_sage_const_1 ,maxV,_sage_const_2 *d))
        else:
            bs = [randint(_sage_const_1 ,maxV-_sage_const_1 )]#we will increase b_0 by 1 later to ensure b_i < b_0
            for i in range(d-_sage_const_1 ):
                bs.append(randint(_sage_const_1 ,bs[i]+_sage_const_1 ))
            
            bs[_sage_const_0 ] += _sage_const_1 
            bs.append(_sage_const_0 )#we need b_d = 0 for below
            cs = [_sage_const_1 ]
            for i in range(d-_sage_const_1 ):
                cs.append(randint(cs[i],bs[_sage_const_0 ]-bs[i+_sage_const_2 ]+_sage_const_1 ))

            arr = bs[:-_sage_const_1 ]+cs
        print("testing array {}".format(arr))
        if distance_regular_graph(arr,existence=True) is True:
            print("array is good!")
            n = number_of_vertices_from_intersection_array(arr)
            if n*arr[_sage_const_0 ] > _sage_const_2 *edgeLimit:
                print("too big")
                continue
            G = distance_regular_graph(arr,check=True)
            print("constructed {}".format(G.name()))
                
    print("tests terminated")
            
test_all()
#test_random_array(60,[3,4,5,6],30)

